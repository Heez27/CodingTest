# 코딩테스트

### ch1. 코딩테스트 개요


### ch2. 


### ch3. 그리디

##### 1) 그리디 Greedy 알고리즘(욕심쟁이 알고리즘): 현재 상황에서 지금 당장 좋은 것만 고르는 방법
   사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형
   
 
    Q1) 당신은 편의점의 계산을 도와주는 점원이다. 
       카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다.
       손님에게 거슬러 줘야 할 돈이 N원일 때, 거슬러줘야 할 동전의 최소 개수를 구하라.
       단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.
       
##### 2) 하지만, 가장 큰 화폐 단위가 나머지 화폐의 배수가 아니라면, 그리디 알고리즘으로 해결할 수 없다. 
 예를 들어, 화폐 단위가 500원, 400원, 100원 인 경우는, <br>
 그리디 방법: 800원 = 500원 + 100원 + 100원 + 100원 (총 4개) <br>
 최적의 방법: 800원 = 400원 + 400원 (총 2개)


##### 3) 큰 수의 법칙: 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것
 예1) [2, 4, 5, 4, 6]이라는 배열이 있고, M = 8, K = 3일때,  <br>
 8개의 숫자를 더하고, 특정한 인덱스의 수가 연속해서 3번까지만 더해질 수 있으므로, <br>
 최적의 방법: 6+6+6+5+ 6+6+6+5 = 46
       
 예2) [3, 4, 3, 4, 3]이라는 배열이 있고, M = 7, K = 2일때,  <br>
 7개의 숫자를 더하고, 특정한 인덱스의 수가 연속해서 2번까지만 더해질 수 있으므로, <br>
 최적의 방법: 4+4+ 4+4+ 4+4+ 4 = 28 (인덱스가 다른 4를 2번씩 더함)
 
 
    Q2) 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 연속으로 더할 수 있는 횟수 K가 주어질 때, 위 큰 수의 법칙에 따른 결과를 출력하시오.
       입력조건: 1. 먼저, N, M, K을 받는다. 단, K<=M이다.
                2. N개의 자연수의 입력을 받는다. 
       출력조건: 위의 큰 수의 법칙에 따라 더해진 답을 출력한다. 
 
##### 4) 숫자 카드 게임: n x m 형태의 카드에서 각 행의 가장 작은 값 중 가장 큰 값을 찾아야함
   
    Q3) N x M 형태로 카드들이 놓여있다고 가정할 때, 각 행의 가장 작은 값 중 가장 큰 값의 카드를 찾아야함
       입력조건: 행의 갯수 n과 열의 갯수 m을 공백을 기준으로 각각 자연수로 입력값을 받음 
       출력조건: 각 행의 가장 작은 값의 카드들 중 가장 큰 값을 출력해야함 

##### 5) 1이 될 때까지

    Q4) 어떠한 수 N이 1이 될 떄까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 함.
      단, 두 번쨰 연산은 N이 K로 나누어떨어질 떄만 선택할 수 있음
       1. N에서 1을 뺀다.
       2. N을 K로 나눈다. 
      실행 결과: N = 17, K = 4일때, 1번 과정 1번, 2번 과정 2번해서 총 3번의 실행 횟수가 결과로 나옴
      실행 결과2: N = 25, K = 5일때, 2번 과정 2번해서 총 2번의 실행 횟수가 결과로 나옴

### ch4. 구현

    Q1) 상하좌우
      여행가 A가 L, R, U, D 중 하나의 문자가 반복적으로 적혀있는 계획서를 보고 이동한다.
      nxn 크기의 정사각형 공간을 벗어나는 움직임은 무시한다.
      (L: 왼쪽으로 한 칸 이동, R: 오른쪽으로 한 칸 이동, U: 위로 한 칸 이동, D: 아래으로 한 칸 이동)

### ch5. DFS/BFS

### ch6. 정렬

### ch7. 이진 탐색

### ch8. 다이나믹 프로그래밍

### ch9. 최단 경로

### ch10. 그래프 이론

