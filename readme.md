# 코딩테스트

### ch1. 코딩테스트 개요


### ch2. 


### ch3. 그리디

##### 1) 그리디 Greedy 알고리즘(욕심쟁이 알고리즘): 현재 상황에서 지금 당장 좋은 것만 고르는 방법
   사전에 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형
   
```python
   # Q1) 그리디 알고리즘
   count_coin += N//coin # *조심하기* /는 결과가 실수, //는 결과가 정수
```
       
##### 2) 하지만, 가장 큰 화폐 단위가 나머지 화폐의 배수가 아니라면, 그리디 알고리즘으로 해결할 수 없다. 
 예를 들어, 화폐 단위가 500원, 400원, 100원 인 경우는, <br>
 그리디 방법: 800원 = 500원 + 100원 + 100원 + 100원 (총 4개) <br>
 최적의 방법: 800원 = 400원 + 400원 (총 2개)


##### 3) 큰 수의 법칙: 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것
 예1) [2, 4, 5, 4, 6]이라는 배열이 있고, M = 8, K = 3일때,  <br>
 8개의 숫자를 더하고, 특정한 인덱스의 수가 연속해서 3번까지만 더해질 수 있으므로, <br>
 최적의 방법: 6+6+6+5+ 6+6+6+5 = 46
       
 예2) [3, 4, 3, 4, 3]이라는 배열이 있고, M = 7, K = 2일때,  <br>
 7개의 숫자를 더하고, 특정한 인덱스의 수가 연속해서 2번까지만 더해질 수 있으므로, <br>
 최적의 방법: 4+4+ 4+4+ 4+4+ 4 = 28 (인덱스가 다른 4를 2번씩 더함)
 
 
```python
# Q2) 큰 수의 법칙

# n, m, k를 공백으로 구분하여 입력받기
n, m, k = map(int, input('').split())

# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input('').split())) # 위 방법에서, list()만 붙여주면 됨

data.sort() # 리스트 정렬하기

```
 
##### 4) 숫자 카드 게임: n x m 형태의 카드에서 각 행의 가장 작은 값 중 가장 큰 값을 찾아야함
   
```python
# Q3) 숫자 카드 게임

# NxM 행렬일 때, 각 행을 따로 입력 받을 수 있음
for i in range(n):
     data = map(int, input('%d행을 입력하시오: '%(i+1)).split()) # 각 행의 m개의 데이터 입력

# min(리스트이름), max(리스트이름)으로 리스트에서 최솟값, 최댓값 찾기
row.append(min(data)) # data라는 리스트의 최솟값을 row라는 리스트에 추가함

# min(비교할 정수들), max(비교할 정수들) 로 최솟값 최댓값 찾기
result = max(result, min(data)) # result라는 정수와 min(data)라는 정수를 비교해, 더 큰값을 result에 넣음

```

##### 5) 1이 될 때까지

```python
# Q4) 1이 될 때까지

# 무한 반복을 위해 while True 문 사용
while True:
    if n == 1:
        break

    elif n%k != 0:
        n -= 1
        count += 1

    else:
        n //= k
        count += 1

```

### ch4. 구현

``` python
# Q1) 상하좌우(L: 왼쪽으로 한 칸 이동, R: 오른쪽으로 한 칸 이동, U: 위로 한 칸 이동, D: 아래으로 한 칸 이동)
   
# 여행 계획 입력받기
plan = list(input('여행 계획: ').split())
   
# move_types와 dx, dy를 리스트로 만들어서, index가 같게 할 수 있음
move_types = ['L', 'R', 'U', 'D']
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
for plan in plans:
    for i in range(len(move_types)):
        # 임시로 이동해본 좌표
        if plan == move_types[i]:
            temp_x = loc[0] + dx[i]
            temp_y = loc[1] + dy[i]
   
```

### ch5. DFS/BFS

### ch6. 정렬

### ch7. 이진 탐색

### ch8. 다이나믹 프로그래밍

### ch9. 최단 경로

### ch10. 그래프 이론

